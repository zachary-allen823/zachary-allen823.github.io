<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Advanced Sorts</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../../indexPages.css">
  </head>
  <body class="projects">

    <h1>Advanced Sorting Algorithms</h1>
    <h2>Merge Sort</h2>
    <p>Merge sort can best be described as a divide and conquer method of sorting arrays. It works by breaking down the larger array into smaller and smaller parts until it is left with only pairs of arrays (and maybe one or two single value arrays if it broke down an array with an odd number of elements) before merging the pairs of arrays back together while sorting them in the process meaning that by the time there are only two separate arrays, it only has to go down each list and compare which number is less before adding it into place in the sorted array. To start, you split the array in half and split those two new arrays in half until you are left with small arrays of one element. Then, you compare pairs of these single element arrays (because they are only one element, they are already considered sorted and are therefore no longer required to be broken down more) and whichever is smaller is appended into a new array followed by the larger number. Eventually, this will leave you with arrays of two elements and maybe one array of one element if you had an odd number of elements in the original array. You then compare pairs of arrays starting with the first indices of each one and appending the smaller of the two to the new array. You then compare the next element of the array that had the smaller number with the first element that was larger because we need to check if one array had more than one smaller number. Repeat this until all of the numbers are sorted into a new array. Repeat this with all the pairs to get larger pairs and then repeat the comparison process until there are only two pairs which will be sorted into one final sorted array.
    <h2>Quick Sort</h2>
    <p>Quick sort is a more efficient divide and conquer method of sorting arrays in which rather than splitting the array in half as it is presented, a 'pivot' element is chosen. This pivot element is most easily chosen as being the first element of the array and the rest of the elements are split into two arrays which contain elements less than the pivot and greater than the pivot respectively. This process is done recursively until there are only one element in the partitioned array. At this point, the partitioning is complete and the elements simply need to be appended into one array as the partitioning already put them in the correct order. To start this process, we start by choosing our pivot element. This can be any element in the array, but for consistency, I find it easiest to use either the first or last element. Once the pivot is selected, each other element in the array is compared to the pivot and are placed on the left or right of the pivot, right for elements larger than the pivot and left for smaller elements. The array is then partitioned leaving the pivot on its own (since it is already technically sorted into place with all values less than it to the left and all elements larger to the right). Each array is sorted using the same process until each side is fully sorted leaving a fully sorted array.
      <h2>Heap Sort</h2>
      <p> Heap sort, unlike the previously mentioned sorts, does not involve splitting the unsorted array in two to sort from there. Instead, heap sort takes the array and forms a binary tree placing the nodes in the order of the array. Each node will have two brances (hence the term binary) and each node at the end of those two branches will also have two branches so on so forth until you run out of elements to place into the tree. Upon completion of this, you must look at each parent node starting from the root (at first this will contain the first element of the array) and check to make sure it is larger than both of its child nodes. If one of or both of the children are larger than the parent node, swap the largest of the two children and the parent so that now the largest of the three values is at the root. Make sure that each node of the tree satisfies this concept so that the largest number in the array is at the root position. In the array, this means that the largest number is at the first index of the array. Now, swap that element with the last element in the array meaning that the largest number is now at the last index which is where it needs to be to be sorted. Once this is done, repeat the same process but omit the last index you sorted a number to so that each time you 'heapify' the array, one less index is used in the tree. Eventually, you will come down to only one parent and one child node. Whichever one is larger will either move to or remain the parent and then that larger number will swap to the last index still being used thus swapping the smaller number into the first slot and the larger into the second leaving you with a fully sorted array.
	<br><br>
	<button class-"projects"; onclick = "window.location.href='./index.html';">Back to index</button>
  </body>

  
</html>
